# JavaScript

## 1. Concurrency Model

[1] has a picture that illustrates the concurrency model (Figure 1):

<img alt="Figure 1: JavaScript Concurrency Model Visual Representation" src="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop/the_javascript_runtime_environment_example.svg" width="30%" height="30%" />

[4] has a similar but slightly different picture (Figure 2):

<img alt="Figure 2: The Platform that JavaScript Runs On" src="https://miro.medium.com/max/4800/1*4lHHyfEhVB0LnQ3HlhSs8g.png" width="40%" height="48%" />

The concurrency of JavaScript is really not only about JavaScript. It includes more components. Read on.

JavaScript itself is **single-threaded**. Therefore, if one piece of JavaScript code (including the functions that this piece of code calls) is running, no other JavaScript code can run. The code and the called functions are run on the **stack** (each function call is a **frame** in it), and the objects that the code access are created on the **heap**.

However, JavaScript runs on a **platform**. On the client side, the platform is usually the browsers; on the server side, the platform is the run-time environment that `Node.js` (and other similar server-side JavaScript run-times) implements. On these platforms, the JavaScript code is executed by the JavaScript engine (e.g., `V8`, `SpiderMonkey`), but the other components that are provided by the platform, together with JavaScript, implement concurrency.

The "other components" on the platform are the **web APIs**, **message queue**, and **event loop**. They are not part of the JavaScript engine but are provided by the platform. Behind the scene, the platform uses the C library `libuv` [6] to implement the web APIs which can run concurrently. In other words, **although the JavaScript code itself is single-threaded, when it calls the web APIs for various functions, these web APIs calls can run concurrently.** This makes JavaScript look "concurrent."

[5] has a picture that illustrates how the calls are made (Figure 3):

<img alt="Figure 3: JavaScript Web API Invocation Process" src="https://felixgerschau.com/static/79486d91b22a7c1b4044fce88a4cae20/29007/js-event-loop-explained.png" width="50%" height="50%" />

When the JavaScript code calls a **web API**, the platform (outside the JavaScript engine) receives the call and starts to do the work. When the work is finished, the platform appends a **message** (which includes the JavaScript callback to notify the results) into the **message queue**. The **event loop** processes the messages in the message queue in the FIFO order and will eventually pick up this newly appended message and call the callback. The callback code is run in the stack to its completion. "Each message is processed completely before any other message is processed." [1]

Note that messages are generated by **not only the calls to web APIs**. As [2] says:

> The Message Queue is also where **user-initiated events** like click or keyboard events, or **fetch responses** are queued before your code has the opportunity to react to them. Or also **DOM events** like onload.

Conceptually, the event loop is implemented as follows [1]:

```javascript
while (queue.waitForMessage()) {
  queue.processNextMessage()
}
```

As [2] says, the event loop "**gives priority to the call stack**, and it first processes everything it finds in the call stack, and **once there's nothing in there, it goes to pick up things in the message queue.**"

[3] provide a deeper look into the event loop which is further divided into a few **phases**.

## 2. Promises and the Job Queue

As [2] puts:

> ECMAScript 2015 introduced the concept of the **Job Queue**, which is used by **Promises** (also introduced in ES6/ES2015). It's a way to execute the result of an async function **as soon as possible, rather than being put at the end of the call stack**.
>
> Promises that resolve before the current function ends will be executed right after the current function.

Because `asyn/await` are built on top of promises, they also use the **job queue** to "jump the queue" when the result is ready.

## 3. Web Workers

As [7] puts:

> Web Workers makes it possible to run a script operation **in a background thread** separate from the main execution thread of a web application. The advantage of this is that laborious processing can be performed in a separate thread, **allowing the main (usually the UI) thread to run without being blocked/slowed down**.
>
> Data is sent between workers and the main thread via a system of messages â€” **both sides** send their messages using the **`postMessage()`** method, and respond to messages via the `onmessage` event handler (the message is contained within the `Message` event's data property). **The data is copied** rather than shared.

Instead of running in the current global context `window`, the web workers **run in a different global context**. Therefore, some of the methods and properties of `window` are not accessible by the web workers.

| Worker Type | Global Context | Description |
|:-----------:|:--------------:|:------------|
| Dedicated worker | DedicatedWorkerGlobalScope | Dedicated workers are workers that are utilized by a single script. |
| Shared worker | SharedWorkerGlobalScope | Can be utilized by multiple scripts running in different windows, IFrames, etc., as long as they are in the same domain as the worker. |
| Service worker | ServiceWorkerGlobalScope | Act as proxy servers that sit between web applications, the browser, and the network (when available). |

## References

- [1] [Concurrency model and the event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
- [2] [The Node.js Event Loop](https://nodejs.dev/learn/the-nodejs-event-loop)
- [3] [The Node.js Event Loop, Timers, and `process.nextTick()`](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick)
- [4] [How JavaScript works: an overview of the engine, the runtime, and the call stack](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf)
- [5] [JavaScript Event Loop And Call Stack Explained](https://felixgerschau.com/javascript-event-loop-call-stack)
- [6] [libuv/libuv](https://github.com/libuv/libuv)
- [7] [Web Workers API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)
- [8] [The Basics of Web Workers](https://www.html5rocks.com/en/tutorials/workers/basics/)
